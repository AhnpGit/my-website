// @flow

import React from 'react'
import PropTypes from 'prop-types'

import Icon from '../Icon/Icon'

type ButtonProps = {
  appearance?: 'primary' | 'secondary' | 'success' | 'error' | 'close',
  hasDropdown?: boolean,
  icon?: string,
  iconSize?: 'xsmall' | 'small' | 'normal' | 'large' | 'xlarge',
  onClick: () => mixed,
  text?: string | React.Element<any>,
  type?: 'button' | 'submit' | 'reset',
}

/**
 * Buttons are generated by the renderButton mixin. This will render an object with button styling (so you can also
 * use this for a Link that needs to look like a button, but still stay semantically correct). Currently we have 5
 * button appearance: primary(default), secondary, success, error and close (to be used for modals/popups).
 */
const Button = ({
                  appearance = 'primary',
                  hasDropdown = false,
                  icon,
                  iconSize = 'small',
                  onClick,
                  text,
                  type = 'button',
                }: ButtonProps) => (
  <button type={type} className={`btn--${appearance}`} onClick={onClick}>
    {icon && <Icon name={icon} fixedSize={iconSize} />}
    {text && <span className="btn__text">{text}</span>}
    {hasDropdown && <Icon name="triangle-down" fixedSize="xsmall" />}
  </button>
)

Button.propTypes = {
  /**
   * The appearance of the button. Available appearances: primary(default), secondary, success, error and close
   */
  appearance: PropTypes.oneOf([ 'primary', 'secondary', 'success', 'error', 'close' ]),

  /**
   * Boolean value that will render a dropdown triangle when set to true.
   */
  hasDropdown: PropTypes.bool,

  /**
   * This will render an icon on the button (not for dropdown arrows)
   */
  icon: PropTypes.string,

  /**
   * Set the size of the icon. Options: xsmall(8px), small(16px), normal(32px), large(48px), xlarge(64px). Size are
   * controlled in the branding util.
   */
  iconSize: PropTypes.oneOf([ 'xsmall', 'small', 'normal', 'large', 'xlarge' ]),

  /**
   * The onClick parameter makes it possible to add events to the component
   */
  onClick({ onClick, type }: ButtonProps, propName: string, componentName: string) {
    if (type !== 'submit' && onClick === undefined) {
      return new Error(`Failed prop type: The prop '${propName}' is marked as required in '${componentName}' when the prop 'type' is not 'submit', but its value is 'undefined'.`)
    }
  },

  /**
   * The type of teh button. Available options: button, submit and reset.
   */
  type: PropTypes.oneOf([ 'button', 'submit', 'reset' ]),

  /**
   * The button text
   */
  text: PropTypes.string,
}

export default Button
